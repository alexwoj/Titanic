# -*- coding: utf-8 -*-
"""TitanicGIT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qlArW_U7sY99Ce5ihgJffPc8wpVtImXa

# Introdução

**Titanic Dataset - Análise de Dados**

Por Alex Wojtowicz
alex.wojtowicz@gmail.com


**OBJETIVO:**

Prever com a maior acurácia possível quais passageiros morerram e quais sobreviveram ao desastre do navio Titanic.

**METODOLOGIA:**

Os datasets serão carregados a partir de arquivos  no formato CSV, sendo um arquivo de treino e outro para testes. O dataset de treino inclui a coluna com a variável resposta (sobrevivente). Já o dataset de testes não inclui esta informação, e será utilizado para testar se o modelo de aprendizado de máquina proposto consegue generalizar a predição com um nível de acurácia satisfatório.

**Iremos dividir esta análise em duas partes: análise descritiva e exploratória de dados, e análise preditiva.**

Os datasets passarão por um processo de limpeza e organização dos dados, os quais serão detalhados ao longo deste notebook.

Ao final do processo de limpeza de dados e análise exploratória, iremos implementar um modelo de aprendizado de máquina. Maiores informações serão detalhadas posteriormente.
"""

# Importando bibliotecas
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import csv,os
from sklearn.preprocessing import OrdinalEncoder

# Carregando datasets

df_treino = pd.read_csv("./content/treinamento.csv", encoding='utf-8',sep=';')
df_teste = pd.read_csv("./content/teste.csv", encoding='utf-8', sep=';')
results_file = './content/resultados.csv'

# Informações sobre o dataset

df_treino.info()
df_teste.info()

"""# Data Cleaning

**Pré-processamento, limpeza e organização dos dados**

Neste processo, quando necessário, vamos eliminar colunas que não são necessárias, procurar por valores faltantes ou NaN (not a number), imputar e escalar valores, transformar variáveis categóricas em numéricas, setar o tipo correto para cada coluna (float, inteiro, texto), detectar eventuais erros e outliers.

Neste primeiro momento, vamos verificar quais são os valores faltantes nos datasets de treino e teste.


"""

print("[DATASET DE TREINO]")
print("")
print("Quantidade de faltantes [poltrona]               : ", df_treino['poltrona'].isnull().sum(),'[',df_treino['poltrona'].isnull().sum()/len(df_treino),']')
print("Quantidade de faltantes [idade]                  : ", df_treino['idade'].isnull().sum(),'[',df_treino['idade'].isnull().sum()/len(df_treino),']')
print("Quantidade de faltantes [local_de_embarque]      : ", df_treino['local_de_embarque'].isnull().sum(),'[',df_treino['local_de_embarque'].isnull().sum()/len(df_treino),']')
print("Quantidade de faltantes [id_passageiro]          : ", df_treino['id_passageiro'].isnull().sum(),'[',df_treino['id_passageiro'].isnull().sum()/len(df_treino),']')
print("Quantidade de faltantes [sexo]                   : ", df_treino['sexo'].isnull().sum(),'[',df_treino['sexo'].isnull().sum()/len(df_treino),']')
print("Quantidade de faltantes [irmaos_e_esposos_abordo]: ", df_treino['irmaos_e_esposos_abordo'].isnull().sum(),'[',df_treino['irmaos_e_esposos_abordo'].isnull().sum()/len(df_treino),']')
print("Quantidade de faltantes [pais_e_filhos_abordo]   : ", df_treino['pais_e_filhos_abordo'].isnull().sum(),'[',df_treino['pais_e_filhos_abordo'].isnull().sum()/len(df_treino),']')
print("Quantidade de faltantes [tarifa]                 : ", df_treino['tarifa'].isnull().sum(),'[',df_treino['tarifa'].isnull().sum()/len(df_treino),']')
print("Quantidade de faltantes [sobrevivente]           : ", df_treino['sobrevivente'].isnull().sum(),'[',df_treino['sobrevivente'].isnull().sum()/len(df_treino),']')
print("")
print("")
print("[DATASET DE TESTES]")
print("")
print("Quantidade de faltantes [poltrona]               : ", df_teste['poltrona'].isnull().sum(),'[',df_teste['poltrona'].isnull().sum()/len(df_teste),']')
print("Quantidade de faltantes [idade]                  : ", df_teste['idade'].isnull().sum(),'[',df_teste['idade'].isnull().sum()/len(df_teste),']')
print("Quantidade de faltantes [tarifa]                 : ", df_teste['tarifa'].isnull().sum(),'[',df_teste['tarifa'].isnull().sum()/len(df_teste),']')
print("Quantidade de faltantes [local_de_embarque]      : ", df_teste['local_de_embarque'].isnull().sum(),'[',df_teste['local_de_embarque'].isnull().sum()/len(df_teste),']')
print("Quantidade de faltantes [id_passageiro]          : ", df_teste['id_passageiro'].isnull().sum(),'[',df_teste['id_passageiro'].isnull().sum()/len(df_teste),']')
print("Quantidade de faltantes [sexo]                   : ", df_teste['sexo'].isnull().sum(),'[',df_teste['sexo'].isnull().sum()/len(df_teste),']')
print("Quantidade de faltantes [irmaos_e_esposos_abordo]: ", df_teste['irmaos_e_esposos_abordo'].isnull().sum(),'[',df_teste['irmaos_e_esposos_abordo'].isnull().sum()/len(df_teste),']')
print("Quantidade de faltantes [pais_e_filhos_abordo]   : ", df_teste['pais_e_filhos_abordo'].isnull().sum(),'[',df_teste['pais_e_filhos_abordo'].isnull().sum()/len(df_teste),']')

"""**Valores Faltantes**

Cerca de 77% dos dados de poltrona/cabine estão faltando no dataset de treino (e 78% no dataset de testes).

Este dataset possui também uma grande quantidade de valores faltantes na coluna idade, sendo 19.86% no dataset de treino e 20.57% no dataset de testes.

Além disso, falta a informação de tarifa de um passageiro no dataset de testes.

Eventualmente, podemos considerar a opção de descartar as linhas com dados faltantes. 

**Entretanto, é um requisito desta análise fazer a previsão para todos os indivíduos listados no dataset de testes, e muitos destes estão com dados faltantes.**

Uma das opções que temos (no caso da idade), é a de preencher estes campos com a média, mediana, moda ou alguma outra estimativa. 

Optei por preencher estes valores com a mediana da idade, levando em consideração o sexo e a classe a qual pertence aquele individuo. A escolha da mediana deve-se ao fato de ela tender a não ser tão distorcida por valores extremos.

Optei também por agrupar as idades em categorias (data binning), divindo os indivíduos em crianças, adolescentes, adultos e idosos, para facilitar algumas análises.

Para o caso da informação de tarifa faltante no dataset de testes, optei preencher este campo com a média das tarifas de classe, local de embarque, sexo e idade semelhantes ao perfil deste passageiro.

Para os dois individuos sem local de embarque, vamos verificar se estavam viajando desacompanhados. Caso estejam desacompanhados, vamos substituir o local de embarque pela moda do local de embarque do dataset de treino.

Obs: será criada uma cópia do dataframe completo),incluindo os dados faltantes, apenas para futura referência, se necessário.

"""

# Fazendo uma cópia completa do dataframe (um backup por precaução)
df_treino_completo = df_treino.copy(deep=True)
df_teste_completo = df_teste.copy(deep=True)

# Imputando valores faltantes na coluna idade, utilizando a mediana segmentada
# por classe e sexo, calculada no dataset de treino.
df_treino.idade.fillna(df_treino.groupby(['sexo','classe']).transform('median').idade.iloc[:df_treino.shape[0]], inplace=True)
df_teste.idade.fillna(df_teste.groupby(['sexo','classe']).transform('median').idade.iloc[:df_treino.shape[0]], inplace=True)

df_treino.info()
df_teste.info()

# Passageiros sem local de embarque
embarque_faltante = df_treino[df_treino['local_de_embarque'].isnull()]

print(embarque_faltante)

# Ambas passageiras estavam viajando juntas, na mesma poltrona (ou cabine),
# e com o mesmo número de ticket. Não foi possível identificar outros
# acompanhantes. Vamos identificar a moda do local_de_embarque para substituir
# esta informação.

df_treino['local_de_embarque'].mode()

# Detectamos que o local de embarque mais frequente é a categoria S
# Vamos substituir os valores faltantes

df_treino['local_de_embarque'].fillna('S',inplace=True)
df_treino.info()

# Criando categorias de idade (bins)
# https://pbpython.com/pandas-qcut-cut.html
#
# 0 - criança     [0 12)
# 1 - adolescente [12 - 18)
# 2 - adulto  [18 - 60)
# 3 - idoso   [60 >)

cut_labels = [0,1,2,3]
cut_bins = [0,12,18,60,120]
df_treino['idade_categoria'] = pd.cut(df_treino['idade'], bins=cut_bins, labels=cut_labels)
df_teste['idade_categoria'] =  pd.cut(df_teste['idade'], bins=cut_bins, labels=cut_labels)

# DATASET/TREINO - Conferindo a distribuição por idade e categoria de idade

sns.histplot(data=df_treino, x="idade", hue="idade_categoria")

# DATASET/TESTE - Conferindo a distribuição por idade e categoria de idade
sns.histplot(data=df_teste, x="idade", hue="idade_categoria")

# Agora vamos lidar com o valor faltante de tarifa no dataset de testes.
#
# Encontrando a linha com tarifa faltante e salvando em novo dataset

linha_tarifa_faltante = df_teste.tarifa.isnull()
df_linha_tarifa_faltante = df_teste[linha_tarifa_faltante]

# Vamos 'dropar' a linha faltante no dataset de testes para poder converter a
# a coluna 'tarifa' para float, sem erros.
df_teste = df_teste.dropna(subset=['tarifa'])

# Convertendo a coluna 'tarifa' de object para float (treino e teste)
df_treino['tarifa'] = df_treino['tarifa'].apply(lambda x: float(x.replace(".","",2).replace(",",".")))
df_teste['tarifa'] = df_teste['tarifa'].apply(lambda x: float(x.replace(".","",2).replace(",",".")))

# Pegando a média da tarifa de acordo com os dados do individuo em 'linha_tarifa_faltante'
# id do passageiro com tarifa faltante é: 1044
# sexo: masculino / categoria_idade: 1 / classe: 3 / porto embarque: S
#
# ( ! ! !  ticket único ! ! ! )
#
# irmaos_e_esposos_abordo = 0 pais_e_filhosabordo = 0 

tarifa_faltante_media_treino = df_treino[(df_treino['sexo'] == 'masculino') & (df_treino['classe'] == 3) & (df_treino['local_de_embarque'] == 'S') & (df_treino['idade_categoria'] == 1) & (df_treino['irmaos_e_esposos_abordo'] == 0) & (df_treino['pais_e_filhos_abordo'] == 0)].tarifa.mean()
tarifa_faltante_media_teste = df_teste[(df_teste['sexo'] == 'masculino') & (df_teste['classe'] == 3) & (df_teste['local_de_embarque'] == 'S') & (df_teste['idade_categoria'] == 1) & (df_teste['irmaos_e_esposos_abordo'] == 0) & (df_teste['pais_e_filhos_abordo'] == 0)].tarifa.mean()
tarifa_faltante_media = (tarifa_faltante_media_treino + tarifa_faltante_media_teste) / 2

# Inserindo a tarifa
df_linha_tarifa_faltante['tarifa'] = df_linha_tarifa_faltante.tarifa.fillna(value=tarifa_faltante_media)

# Juntando os datasets
df_teste = pd.concat([df_teste, df_linha_tarifa_faltante])

# Devemos ter 418 linhas em tarifa
df_teste.info()

"""

---


Apesar de termos 77% de dados faltantes na coluna poltrona, optei por não remove-la por completo. 

Vamos transformar esta coluna, considerando apenas a primeira letra da poltrona, para investigar se a letra inicial indica algum tipo de classe de cabine, e assim investigar se existe alguma correlação com a taxa de sobrevivência. Caso exista, podemos criar uma feature no processo de análise preditiva.

Para poltronas faltantes, irei substituir o NaN pela letra X.

Porém, optei por remover a coluna 'bilhete'. Pode ser que ela traga alguma informação em seu texto, por exemplo, alguma maneira de identificar se o indivíduo é passageiro ou tripulante, ou alguma outra condição especial. Entretanto, não dispomos desta informação no momento.

"""

# DATASET/TREINO - Substituição campo poltrona

for i in range(len(df_treino)):
    try:        
        poltrona = df_treino['poltrona'].loc[i]
        primeira_letra = str(poltrona)[0]                
        if(primeira_letra == 'n'):
            primeira_letra = 'X'        
        df_treino.loc[df_treino['poltrona'] == poltrona, 'poltrona'] = primeira_letra        
    except:                
        print('erro',i)

df_treino['poltrona'] = df_treino['poltrona'].fillna('X')

# DATASET/Teste - Substituição campo poltrona

for i in range(len(df_teste)):
    try:        
        poltrona = df_teste['poltrona'].loc[i]
        primeira_letra = str(poltrona)[0]                
        if(primeira_letra == 'n'):
            primeira_letra = 'X'        
        df_teste.loc[df_teste['poltrona'] == poltrona, 'poltrona'] = primeira_letra        
    except:                
        print('erro',i)
df_teste['poltrona'] = df_teste['poltrona'].fillna('X')

# Dropando a coluna bilhete

df_treino.drop(['bilhete'],axis=1,inplace=True)
df_teste.drop(['bilhete'], axis=1,inplace=True)
df_treino.info()

"""# Análise Exploratória de Dados

Nesta fase, vamos analisar os dados visualmente e com estatísticas descritivas básicas, para encontrar padrões e informações importantes que poderão sugerir features para nosso modelo de aprendizado de máquina.

O objetivo aqui é descobrir o que pode afetar a taxa de mortalidade dos indivíduos com base em cortes e segmentos específicos.

Questões principais a serem exploradas:

*   Qual a relação entre o sexo e a taxa de mortalidade?

*   Qual a relação entre idade e a taxa de mortalidade?

* Qual a relação entre a classe de embarque e tarifas e a taxa de mortalidade?

Ao longo da exploração dos dados, vamos segmentando cada uma das questões acima em cortes cada vez mais específicos (por exemplo, no sexo masculino, quais as faixas etárias mais atingidas por uma alta taxa de mortalidade).

Ao final deste processo, teremos algumas hipóteses para explorar.

**Vamos começar com a relação entre o sexo e a taxa de mortalidade.**

Obs: a análise será realizada no dataset de treino, pois necessitamos da coluna 'sobrevivente' para explorar os resultados.


"""

sns.displot(df_treino, x="sexo", hue="sobrevivente", multiple="stack", legend=False)
plt.legend(title='Sobreviventes x Sexo', loc='upper left', labels=['Sobrevive', 'Não Sobrevive'])

# Números em percentual
total_masculino = len(df_treino[(df_treino['sexo'] == 'masculino')])
total_feminino = len(df_treino[(df_treino['sexo'] == 'feminino')])
mortes_masculino = len(df_treino[(df_treino['sexo'] == 'masculino') & (df_treino['sobrevivente']=='Não')])
mortes_feminino = len(df_treino[(df_treino['sexo'] == 'feminino') & (df_treino['sobrevivente']=='Não')])
print("Taxa de Mortalidade")
print("----------------------")
print("Total Passageiros    :", total_masculino + total_feminino)
print("Total Passageiros [H]:", total_masculino)
print("Total Passageiras [F]:", total_feminino)
print("Total Mortes         :", mortes_masculino + mortes_feminino)
print("Total Mortes [M]     :", mortes_masculino)
print("Total Mortes [F]     :", mortes_feminino)
print("TxMortalidade Total  :", (mortes_masculino + mortes_feminino) / (total_masculino + total_feminino))
print("TxMortalidade [M]    :", mortes_masculino/total_masculino)
print("TxMortalidade [F]:",mortes_feminino/total_feminino)

"""**Fica bem claro que a taxa de mortalidade é muito maior entre os homens. Vamos descobrir se existe alguma relação com a faixa etária.**"""

# 0 - criança     [0 12)
# 1 - adolescente [12 - 18)
# 2 - adulto  [18 - 60)
# 3 - idoso   [60 >)

df_treino_masculino = df_treino[(df_treino['sexo'] == 'masculino')]
sns.histplot(data=df_treino_masculino, x="idade_categoria", hue="sobrevivente", multiple="stack")

sns.histplot(data=df_treino_masculino, x="idade", hue="sobrevivente", multiple="stack")

# Vou verificar a taxa de mortalidade por categoria de idade

tx_mort_cat0 = len(df_treino_masculino[(df_treino_masculino['idade_categoria'] == 0) & (df_treino_masculino['sobrevivente'] == 'Não')]) / len(df_treino_masculino[df_treino_masculino['idade_categoria'] == 0])
tx_mort_cat1 = len(df_treino_masculino[(df_treino_masculino['idade_categoria'] == 1) & (df_treino_masculino['sobrevivente'] == 'Não')]) / len(df_treino_masculino[df_treino_masculino['idade_categoria'] == 1])
tx_mort_cat2 = len(df_treino_masculino[(df_treino_masculino['idade_categoria'] == 2) & (df_treino_masculino['sobrevivente'] == 'Não')]) / len(df_treino_masculino[df_treino_masculino['idade_categoria'] == 2])
tx_mort_cat3 = len(df_treino_masculino[(df_treino_masculino['idade_categoria'] == 3) & (df_treino_masculino['sobrevivente'] == 'Não')]) / len(df_treino_masculino[df_treino_masculino['idade_categoria'] == 3])

print("Mortalidade por Faixa Etária")
print("Sexo: Masculino")
print("----------------------------")
print("0-12: ", tx_mort_cat0)
print("12-18: ", tx_mort_cat1)
print("18-60: ", tx_mort_cat2)
print("60>: ", tx_mort_cat3)

"""

---


Entre as crianças do sexo masculino, a taxa de mortalidade fica abaixo da taxa de mortalidade média do total das amostras analisadas (43% contra 61%). 

Entretanto, nas outras faixas etárias, a taxa de mortalidade dos homens é muito mais alta que a taxa de mortalidade média.

**Vamos fazer um corte de taxa de mortalidade entre os homens vs classe de embarque?**


---

"""

sns.histplot(data=df_treino_masculino, x="classe", hue="sobrevivente", multiple="stack")

tx_mort_class1 = len(df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['sobrevivente'] == 'Não')]) / len(df_treino_masculino[df_treino_masculino['classe'] == 1])
tx_mort_class2 = len(df_treino_masculino[(df_treino_masculino['classe'] == 2) & (df_treino_masculino['sobrevivente'] == 'Não')]) / len(df_treino_masculino[df_treino_masculino['classe'] == 2])
tx_mort_class3 = len(df_treino_masculino[(df_treino_masculino['classe'] == 3) & (df_treino_masculino['sobrevivente'] == 'Não')]) / len(df_treino_masculino[df_treino_masculino['classe'] == 3])

print("----------------------------")
print("Mortalidade por Classe")
print("Sexo: Masculino")
print("----------------------------")
print("Classe 1:", tx_mort_class1)
print("Classe 2: ", tx_mort_class2)
print("Classe 3: ", tx_mort_class3)

"""**Fica evidente que a taxa de mortalidade é muito maior entre homens que estão nas segundas e terceiras classe.**

Agora, vamos analisar a faixa etária das 3 classes, para ver se existe alguma espécie de "perfil demográfico".
"""

sns.catplot(x="classe", y="idade", hue="sobrevivente", kind="bar", data=df_treino_masculino)

g = sns.FacetGrid(df_treino_masculino, col="classe", hue="sobrevivente")
g.map(sns.histplot,"idade_categoria")

"""---

**Podemos observar claramente que homens adultos na Primeira Classe tem uma chance de sobrevivência muito maior do que homens adultos em outras classes.**

Os idosos não obtiveram sucesso para escapar do desastre, mesmo aqueles que estavam na primeira classe.

Vamos calcular os percentuais de taxa de mortalidade por faixa etária e classe!

---
"""

tx_mort_class1_crianca = len(df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 0)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['idade_categoria'] == 0)])
tx_mort_class2_crianca = len(df_treino_masculino[(df_treino_masculino['classe'] == 2) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 0)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 2) & (df_treino_masculino['idade_categoria'] == 0)])
tx_mort_class3_crianca = len(df_treino_masculino[(df_treino_masculino['classe'] == 3) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 0)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 3) & (df_treino_masculino['idade_categoria'] == 0)])

tx_mort_class1_adolescente = len(df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 1)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['idade_categoria'] == 1)])
tx_mort_class2_adolescente = len(df_treino_masculino[(df_treino_masculino['classe'] == 2) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 1)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 2) & (df_treino_masculino['idade_categoria'] == 1)])
tx_mort_class3_adolescente = len(df_treino_masculino[(df_treino_masculino['classe'] == 3) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 1)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 3) & (df_treino_masculino['idade_categoria'] == 1)])

tx_mort_class1_adulto = len(df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 2)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['idade_categoria'] == 2)])
tx_mort_class2_adulto = len(df_treino_masculino[(df_treino_masculino['classe'] == 2) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 2)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 2) & (df_treino_masculino['idade_categoria'] == 2)])
tx_mort_class3_adulto = len(df_treino_masculino[(df_treino_masculino['classe'] == 3) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 2)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 3) & (df_treino_masculino['idade_categoria'] == 2)])

tx_mort_class1_idoso = len(df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 3)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['idade_categoria'] == 3)])
tx_mort_class2_idoso = len(df_treino_masculino[(df_treino_masculino['classe'] == 2) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 3)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 2) & (df_treino_masculino['idade_categoria'] == 3)])
tx_mort_class3_idoso = len(df_treino_masculino[(df_treino_masculino['classe'] == 3) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 3)]) / len(df_treino_masculino[(df_treino_masculino['classe'] == 3) & (df_treino_masculino['idade_categoria'] == 3)])

print("-----------------------------------------")
print("Tx. Mortalidade por Classe e Faixa Etária")
print("Sexo: Masculino")
print("-----------------------------------------")
print("CLASSE1/CRIANCA     :", tx_mort_class1_crianca)
print("CLASSE1/ADOLESCENTE :", tx_mort_class1_adolescente)
print("CLASSE1/ADULTO      :", tx_mort_class1_adulto)
print("CLASSE1/IDOSO       :", tx_mort_class1_idoso)
print("")
print("CLASSE2/CRIANCA     :", tx_mort_class2_crianca)
print("CLASSE2/ADOLESCENTE :", tx_mort_class2_adolescente)
print("CLASSE2/ADULTO      :", tx_mort_class2_adulto)
print("CLASSE2/IDOSO       :", tx_mort_class2_idoso)
print("")
print("CLASSE3/CRIANCA     :", tx_mort_class3_crianca)
print("CLASSE3/ADOLESCENTE :", tx_mort_class3_adolescente)
print("CLASSE3/ADULTO      :", tx_mort_class3_adulto)
print("CLASSE3/IDOSO       :", tx_mort_class3_idoso)
print("")

"""

---
Temos uma grande concentração de passageiros de sexo masculino, faixa etária adulta, na segunda e terceira classe. Este é o segmento onde tivemos o maior volume de mortes.



---

**Vamos agora analisar a taxa de mortalidade entre as mulheres!**

"""

# Relembrando a taxa de mortalidade no segmento 'sexo = feminino'
print(mortes_feminino/total_feminino)

"""**Onde estão concentradas as mortes?**

Vamos analisar por ordem:


*   Taxa de mortalidade por faixa etária
*   Taxa de mortalidade por classe

Havendo necessidade, vamos segmentar um pouco mais os cortes.

Vamos lá!


"""

# Corte principal, sexo feminino
df_treino_feminino = df_treino[(df_treino['sexo'] == 'feminino')]

# Vamos olhar "por cima" quem não sobrevive, do sexo feminino.
df_treino_feminino_n_sobrevive = df_treino_feminino[(df_treino_feminino['sobrevivente'] == 'Não')]

df_treino_feminino_n_sobrevive

# Agora vamos fazer um corte por sexo feminino, categoria de idade

sns.histplot(data=df_treino_feminino, x="idade_categoria", hue="sobrevivente", multiple="stack",palette='husl')

# E agora vamos fazer um corte por classes!

g = sns.FacetGrid(df_treino_feminino, col="classe", hue="sobrevivente",palette='husl')
g.map(sns.histplot,"idade_categoria")

"""

---
Novamente, temos uma alta taxa de mortalidade entre os indivíduos (mulheres) da classe 3, enquanto as mulheres nas classes 1 e 2 tem uma chance muito maior de sobreviver.

Além disso, o maior volume de indivíduos do sexo feminino estão concentrados na primeira classe, e são mulheres adultas. Além da vantagem de estarem em um deck mais preparado (botes, coletes, saída para o mar), também tem maiores condições físicas para se salvar.

---
**Vamos falar sobre as crianças e adolescentes? Qual será a taxa de mortalidade?**

"""

#df_treino_masculino[(df_treino_masculino['classe'] == 1) & (df_treino_masculino['sobrevivente'] == 'Não') & (df_treino_masculino['idade_categoria'] == 1)])
df_criancas = df_treino[(df_treino['idade_categoria'] == 1) | (df_treino['idade_categoria'] == 0)]
df_criancas_mort = df_criancas[df_criancas['sobrevivente'] == 'Não']

# Qual foi a taxa de mortalidade?
tx_mort_criancas = len(df_criancas_mort) / len(df_criancas)

print("-----------------------")
print("Crianças & Adolescentes")
print("-----------------------")
print("Total         : ",len(df_criancas))
print("Mortes        : ",len(df_criancas_mort))
print("TxMortalidade :", tx_mort_criancas)

sns.histplot(data=df_criancas, x="idade", hue="sobrevivente", multiple="stack",palette='Set2')

g = sns.FacetGrid(df_criancas, col="classe", hue="sobrevivente",palette='Set2')
g.map(sns.histplot,"idade_categoria")

"""

---
As distribuições acima mostram que as crianças da primeira classe tiveram uma chance maior de sobreviver. 

Adolescentes da classe 2, crianças e adolescentes da classe 3 tiveram chances muito menores de sobreviver.


---

**Pergunta: Será que existiam crianças ou adolescentes desacompanhados de mães, pais ou irmãos?**

"""

df_criancas_acompanhadas = df_criancas[(df_criancas['irmaos_e_esposos_abordo'] != 0) | (df_criancas['pais_e_filhos_abordo'] != 0)]
df_criancas_desacompanhadas = df_criancas[(df_criancas['irmaos_e_esposos_abordo'] == 0) & (df_criancas['pais_e_filhos_abordo'] == 0)]

print("Desacompanhadas: ", len(df_criancas_desacompanhadas))
print("Acompanhadas   : ", len(df_criancas_acompanhadas))

"""**E qual será a taxa de mortalidade deste segmento em comparação com as crianças acompanhadas??**"""

df_desacompanhadas_n_sobrevive = df_criancas_desacompanhadas[df_criancas_desacompanhadas['sobrevivente'] == 'Não']
df_acompanhadas_n_sobrevive = df_criancas_acompanhadas[df_criancas_acompanhadas['sobrevivente'] == 'Não']

print("TxMortalidade Desacompanhadas: ", len(df_desacompanhadas_n_sobrevive) / len(df_criancas_desacompanhadas))
print("TxMortalidade Acompanhadas   : ", len(df_acompanhadas_n_sobrevive) / len(df_criancas_acompanhadas))

"""

---
E qual será o perfil de faixa etária das crianças ou adolescentes desacompanhadas?


---


"""

sns.histplot(data=df_criancas_desacompanhadas, x="idade", hue="sobrevivente", multiple="stack",palette='Set2')

"""

---
Como podemos observar pela distribuição acima, temos em sua grande maioria adolescentes desacompanhados (como poderíamos imaginar).

---

Ao analisar os dados, podemos observar uma grande relação entre a classe ao qual o passageiro estava viajando e a taxa de sobrevivência.

**Será que a tarifa paga tem relação com a taxa de sobrevivência?**

Vamos plotar um gráfico de dispersão.



"""

fig, ax = plt.subplots(figsize=(16,10))
plt.xlim(-5,200)

with sns.plotting_context('notebook',font_scale=1.2):

    ax = sns.scatterplot(
        x='tarifa',
        y='idade',
        hue='sobrevivente',
        palette=['red','blue'],
        data=df_treino,
        ax=ax
    )

"""

---
De fato, temos uma maior taxa de mortalidade nas tarifas menores!

**Vamos visualizar a taxa de sobrevivência nas diferentes classes?**
"""

sns.histplot(data=df_treino, x="classe", hue="sobrevivente", multiple="stack",palette='Set2')

"""---
# Análise Exploratória de Dados - Conclusão

Ficou bem evidente que os indivíduos do sexo masculino, que estavam na segunda ou terceira classe, foram os que tiveram menos chance de sobreviver.

As mulheres e crianças, por sua vez, se sairam melhor neste desastre, exceto aquelas que estavam viajando na terceira classe.

Fica evidente a relação entre a condição social do passageiro com a taxa de mortalidade, provavelmente por estes estarem viajando em cabines internas, mais precárias e com menos dispositivos de segurança.

Poderíamos contar muitas outras histórias com estes dados, entretanto, ainda temos uma análise preditiva pela frente.


---

# Análise Predititiva

Vamos inciar agora a análise preditiva, utilizando técnicas de aprendizado de máquina, para estimar se um passageiro poderia sobreviver ou não a esta tragédia.

O algoritmo selecionado para esta análise é o Random Forest.

Optei por este algoritmo por ele ser simples de implementar, trabalhar bem com classificação, e também pelo fato de o mesmo apresentar uma "explicação" sobre as decisões tomadas e as features mais importantes (podemos visualizar a 'feature importance' e ver quais features tem mais peso na tomada de decisão).

Para começar, vamos converter os dados categóricos em numéricos, pois máquinas gostam de números!
"""

#DATASET/TREINO -  Convertendo dados categóricos em numéricos
df_treino['sexo'] = OrdinalEncoder().fit_transform(df_treino['sexo'].values.reshape((-1, 1)))
df_treino['poltrona'] = OrdinalEncoder().fit_transform(df_treino['poltrona'].values.reshape((-1, 1)))
df_treino['local_de_embarque'] = OrdinalEncoder().fit_transform(df_treino['local_de_embarque'].values.reshape((-1, 1)))
df_treino['sobrevivente']  = OrdinalEncoder().fit_transform(df_treino['sobrevivente'].values.reshape((-1, 1)))


# Convertendo float para int
# 
# A idade será mantida como float, pois idades estimadas estão no formato xx.5
df_treino['sexo'] = df_treino['sexo'].apply(lambda x: int(x))
df_treino['poltrona'] = df_treino['poltrona'].apply(lambda x: int(x))
df_treino['local_de_embarque'] = df_treino['local_de_embarque'].apply(lambda x: int(x))
df_treino['sobrevivente'] = df_treino['sobrevivente'].apply(lambda x: int(x))
df_treino['idade_categoria'] = df_treino['idade_categoria'].apply(lambda x: int(x))

#DATASET/TESTE -  Convertendo dados categóricos em numéricos
df_teste['sexo'] = OrdinalEncoder().fit_transform(df_teste['sexo'].values.reshape((-1, 1)))
df_teste['poltrona'] = OrdinalEncoder().fit_transform(df_teste['poltrona'].values.reshape((-1, 1)))
df_teste['local_de_embarque'] = OrdinalEncoder().fit_transform(df_teste['local_de_embarque'].values.reshape((-1, 1)))

# Convertendo float para int
# 
# A idade será mantida como float, pois idades estimadas estão no formato xx.5
df_teste['sexo'] = df_teste['sexo'].apply(lambda x: int(x))
df_teste['poltrona'] = df_teste['poltrona'].apply(lambda x: int(x))
df_teste['local_de_embarque'] = df_teste['local_de_embarque'].apply(lambda x: int(x))
df_teste['idade_categoria'] = df_teste['idade_categoria'].apply(lambda x: int(x))

df_treino.info()

# Importando a caixa de ferramentas!

from sklearn.ensemble import RandomForestClassifier
import sklearn.model_selection as model_selection
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.model_selection import RandomizedSearchCV

"""

---
**Feature Engineering**

Vamos criar novas features a partir de hipóteses levantadas durante a exploração dos dados.


---

"""

# Novas features
#
# Pessoas de sexo masculino (1) e classe 3 (3)
# Explicação: grupo com maior taxa de mortalidade

df_treino['masc_class_3'] = np.where((df_treino['classe'] == 3) & (df_treino['sexo'] == 1), 1,0)
df_teste['masc_class_3'] = np.where((df_teste['classe'] == 3) & (df_teste['sexo'] == 1), 1,0)

# Crianças desacompanhadas
# Explicação: crianças desacompanhadas apresentaram maior taxa de mortalidade

df_treino['desacompanhadas'] = np.where((df_treino['irmaos_e_esposos_abordo'] == 0) & (df_treino['pais_e_filhos_abordo'] == 0), 1,0)
df_teste['desacompanhadas'] = np.where((df_teste['irmaos_e_esposos_abordo'] == 0) & (df_teste['pais_e_filhos_abordo'] == 0), 1,0)

# Idade fracionada (estimada)
# Explicação: pessoas com idade estimada provavelmente não sobreviveram
df_treino['idade_estimada'] = np.where(df_treino['idade'] % 1 == 0, 0, 1)
df_teste['idade_estimada'] = np.where(df_teste['idade'] % 1 == 0, 0, 1)

# Tarifa < 50
# Explicação: de acordo com o gráfico de dispersão, tarifas mais baixas concentram
# o maior volume de mortes
df_treino['tarifa1'] = np.where(df_treino['tarifa'] < 50, 0, 1)
df_teste['tarifa1'] = np.where(df_teste['tarifa'] < 50, 0, 1)

# Tarifa < 50 idade > 20
# Explicação: Segmento concentra alta taxa de mortalidade
df_treino['tarifa2'] = np.where((df_treino['tarifa'] < 50) & (df_treino['idade'] > 20), 0, 1)
df_teste['tarifa2'] = np.where((df_teste['tarifa'] < 50) & (df_teste['idade'] > 20), 0, 1)

# Preparando o terreno
# Vamos aqui dropar a coluna id_passageiro, que não apresentará serventia para
# o nosso processo.


X = df_treino.drop(["sobrevivente", "id_passageiro"], axis=1)
y = df_treino['sobrevivente']
X_train, X_test, y_train, y_test = model_selection.train_test_split(X, y, train_size=0.8, test_size=0.2, random_state=42)

"""**ATENÇÃO!**

Inclui no último bloco deste notebook alguns passos para fazer o auto tunning de hiperparâmetros com validaçao cruzada.

Utilizo sempre a mesma semente aleatória (42), para que o mesmo resultado possa ser replicado em diferentes ocasiões.

Os resultados obtidos no último passo foram inseridos no classificador que está rodando neste notebook.
"""

# Vamos ver como o modelo se sai?

rf = RandomForestClassifier(n_estimators=522, max_features='auto', max_depth=110,oob_score=True)
rf.fit(X_train, y_train)
rf_predict = rf.predict(X_test)


print("=== Feature Importance ===")
print(sorted(zip(map(lambda x: round(x, 4), rf.feature_importances_), X), reverse=True))

print("=== MATRIZ DE CONFUSÃO ===")
print(confusion_matrix(y_test, rf_predict))
print('\n')
print("=== MÉTRICAS ===")
print(classification_report(y_test, rf_predict,digits=4))
print('\n')

"""**PREDITOR**

Agora vamos ler o dataset de testes, linha por linha, passar para do predict e vamos gravar o arquivo de resultados.
"""

i = 0

for row in range(len(df_teste)):
    id_passageiro = df_teste['id_passageiro'][i]
    tarifa = df_teste['tarifa'][i]
    idade = df_teste['idade'][i]
    sexo = df_teste['sexo'][i]
    poltrona = df_teste['poltrona'][i]
    classe = df_teste['classe'][i]
    masc_class_3 = df_teste['masc_class_3'][i]
    irmaos_e_esposos_abordo = df_teste['irmaos_e_esposos_abordo'][i]
    local_de_embarque = df_teste['local_de_embarque'][i]
    pais_e_filhos_abordo = df_teste['pais_e_filhos_abordo'][i]
    idade_categoria = df_teste['idade_categoria'][i]
    tarifa2 = df_teste['tarifa2'][i]
    desacompanhadas = df_teste['desacompanhadas'][i]
    idade_estimada = df_teste['idade_estimada'][i]
    tarifa1 = df_teste['tarifa1'][i]    
    values = pd.DataFrame({"tarifa":[tarifa],"idade":[idade],"sexo": [sexo],"poltrona": [poltrona],"classe":[classe],"masc_class_3": [masc_class_3],"irmaos_e_esposos_abordo":[irmaos_e_esposos_abordo],"local_de_embarque":[local_de_embarque],"pais_e_filhos_abordo":[pais_e_filhos_abordo],"idade_categoria":[idade_categoria],"tarifa2":[tarifa2],"desacompanhadas":[desacompanhadas],"idade_estimada": [idade_estimada],"tarifa1": tarifa1})
    results_rf = rf.predict(values.fillna(0))
    print("ID: ", id_passageiro, "Resultado: ", results_rf)    

    file_exists = os.path.isfile(results_file)
    with open(results_file, 'a',encoding='utf-8',newline='') as csvfile:
        headers = ['id_passageiro','sobrevivente']
        fieldnames = ['id_passageiro','sobrevivente']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames, quotechar='"',quoting=csv.QUOTE_MINIMAL,delimiter=';')
        if not file_exists:
            writer.writeheader()        
        if(results_rf[0] == 0):
            sobrevivente = 'Não'
        if(results_rf[0] == 1):
            sobrevivente = 'Sim'
        writer.writerow({'id_passageiro': id_passageiro,'sobrevivente': sobrevivente})
    i+= 1



"""

---
O resultado poderia ter sido mais satisfatório?

Então vamos rodar um tunning de hiperparametros e validação cruzada!


---


"""

# n_estimators = [int(x) for x in np.linspace(start = 100, stop = 2000, num = 10)]
# max_features = ['auto', 'sqrt','log2']
# max_depth = [int(x) for x in np.linspace(100, 200, num = 11)]
# max_depth.append(None)
# random_grid = {
#     'n_estimators': n_estimators,
#     'max_features': max_features,
#     'max_depth': max_depth
#     }

# rf_random = RandomizedSearchCV(estimator = rf, param_distributions = random_grid, n_iter = 10, cv = 10, verbose=2, random_state=42, n_jobs = -1)
# rf_random.fit(X_train, y_train)
# print(rf_random.best_params_)

"""

---

**OBRIGADO!**"""